package org.opentestsystem.ap.itemcompare.service;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.itemcompare.ApplicationProperties;
import org.opentestsystem.ap.itemcompare.comparer.ItemComparer;
import org.opentestsystem.ap.itemcompare.model.CompareContext;
import org.opentestsystem.ap.itemcompare.report.ReportWriter;
import org.springframework.core.io.ClassPathResource;

import java.util.HashSet;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.ap.itemcompare.CompareModelSupport.itemComparison;
import static org.opentestsystem.ap.itemcompare.CompareModelSupport.itemDifference;

@RunWith(MockitoJUnitRunner.class)
public class CompareServiceTest {

    @Spy
    private ApplicationProperties applicationProperties = new ApplicationProperties();

    @Mock
    private ItemProvider itemProvider;

    @Mock
    private ItemComparer itemComparerA;

    @Mock
    private ItemComparer itemComparerB;

    @Spy
    private Set<ItemComparer> comparers = new HashSet<>();

    @Mock
    private ReportService reportService;

    @Mock
    private ReportWriter summaryWriter;

    @Mock
    private ReportWriter itemWriter;

    @InjectMocks
    private CompareService compareService;

    @Before
    public void setup() throws Exception {
        when(itemComparerA.getDifferenceTypes()).thenReturn(ImmutableList.of("DIFF_A1", "DIFF_A2"));
        when(itemComparerA.getName()).thenReturn("comparerA");
        when(itemComparerA.compare(any())).thenReturn(ImmutableList.of(
            itemDifference("DIFF_A1"),
            itemDifference("DIFF_A1"),
            itemDifference("DIFF_A2")
        ));

        when(itemComparerB.getDifferenceTypes()).thenReturn(ImmutableList.of("DIFF_B1", "DIFF_B2"));
        when(itemComparerB.getName()).thenReturn("comparerB");
        when(itemComparerB.compare(any())).thenReturn(ImmutableList.of(
            itemDifference("DIFF_B1"),
            itemDifference("DIFF_B2"),
            itemDifference("DIFF_B2")
        ));

        comparers.addAll(ImmutableSet.of(itemComparerA, itemComparerB));

        when(itemProvider.getComparison(any())).thenAnswer(invocation -> {
            final String itemId = invocation.getArgumentAt(0, String.class);
            return itemComparison(itemId);
        });

        when(reportService.getItemReportWriter(any(), any())).thenReturn(itemWriter);
        when(reportService.getSummaryReportWriter(any(), any())).thenReturn(summaryWriter);

        final ClassPathResource compareIds = new ClassPathResource("test-compare-ids.txt");
        applicationProperties.setCompareIdFileName(compareIds.getFile().getPath());
        applicationProperties.setComparers(ImmutableSet.of("all"));
    }

    @Test
    public void itShouldCompareItems() throws Exception {
        compareService.compare();

        verify(itemProvider, times(3)).getComparison(any());

        verify(itemComparerA, times(3)).compare(any());
        verify(itemComparerB, times(3)).compare(any());

        verify(summaryWriter, times(3)).writeDifferences(any());
        verify(summaryWriter).close();
        verify(itemWriter, times(3)).writeDifferences(any());
        verify(itemWriter, times(3)).close();

        verify(itemProvider, times(3)).cleanup(any());
    }

    @Test
    public void itShouldUseSingleConfiguredComparer() {
        applicationProperties.setComparers(ImmutableSet.of("comparerB"));
        compareService.compare();

        verify(itemComparerB, times(3)).compare(any());
        verify(itemComparerA, never()).compare(any());
    }

    @Test
    public void itShouldUseMultipleConfiguredComparers() {
        applicationProperties.setComparers(ImmutableSet.of("comparerA", "comparerB"));
        compareService.compare();

        verify(itemComparerB, times(3)).compare(any());
        verify(itemComparerA, times(3)).compare(any());
    }

    @Test
    public void itShouldRecordErrors() {
        when(itemComparerA.compare(any()))
            .thenThrow(new IllegalArgumentException("Bad stuffs"));

        compareService.compare();

        final ArgumentCaptor<CompareContext> contextCaptor = ArgumentCaptor.forClass(CompareContext.class);
        verify(summaryWriter, times(3)).writeDifferences(contextCaptor.capture());

        contextCaptor.getAllValues().forEach(compareContext -> {
            assertThat(compareContext.isFailed()).isTrue();
            assertThat(compareContext.getErrorMessages()).containsOnly("Bad stuffs");
            assertThat(compareContext.getDifferences()).hasSize(3);
        });

    }
}