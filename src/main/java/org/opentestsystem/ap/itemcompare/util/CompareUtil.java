package org.opentestsystem.ap.itemcompare.util;

import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.keyvalue.MultiKey;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.xerces.dom.DeferredAttrImpl;
import org.apache.xerces.dom.DeferredTextImpl;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.itemcompare.CompareService;
import org.opentestsystem.ap.itemcompare.model.FileCompareInfo;
import org.opentestsystem.ap.itemcompare.report.CompareReport;
import org.opentestsystem.ap.itemcompare.report.CompareReportFile;
import org.springframework.stereotype.Component;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xmlunit.builder.DiffBuilder;
import org.xmlunit.builder.Input;
import org.xmlunit.diff.Comparison;
import org.xmlunit.diff.ComparisonType;
import org.xmlunit.diff.DefaultNodeMatcher;
import org.xmlunit.diff.Diff;
import org.xmlunit.diff.Difference;
import org.xmlunit.diff.ElementSelectors;

import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathFactory;
import java.io.File;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Compare application utilities
 */
@Component
@NoArgsConstructor
@Slf4j
public class CompareUtil {
    private static final int MAX_IMPORT_ITEM_ID = 200000;

    private static final int RANDOM_DIR_NAME_CHAR_LENGTH = 8;

    private static final String QUOTE = "\"";

    private static final String COMMA = ",";

    private static final String NOT_FOUND = "NOT_FOUND";

    private static final String IMPORT_FILE_NOT_FOUND = "IMPORT_FILE_NOT_FOUND";

    private static final String TIMS_FILE_NOT_FOUND = "TIMS_FILE_NOT_FOUND";

    /**
     * Checks if the item id is from an imported item
     *
     * @param itemId
     * @return
     */
    public static boolean isImported(String itemId) {
        return Integer.parseInt(itemId) < MAX_IMPORT_ITEM_ID;
    }

    /**
     * Creates a directory with a random alphanumeric name
     *
     * @param localBaseDir
     * @return
     */
    public static Path createLocalRandomPath(String localBaseDir) {
        Path localRepositoryPath = Paths.get(localBaseDir, RandomStringUtils.randomAlphabetic(RANDOM_DIR_NAME_CHAR_LENGTH));
        localRepositoryPath.toFile().mkdirs();
        return localRepositoryPath;
    }

    /**
     * Creates a directory to store item compare report files
     *
     * @param localBaseDir
     * @return
     */
    public static Path createLocalReportPath(String localBaseDir, String reportDir) {
        Path localRepositoryPath = Paths.get(localBaseDir, reportDir);
        localRepositoryPath.toFile().mkdirs();
        return localRepositoryPath;
    }

    /**
     *
     * @return
     */
    public static String getReportName() {
        return new SimpleDateFormat("'tims-compare-'yyyyMMddHHmmss").format(new Date());
    }

    /**
     * Converts a text file into a collection. One element per line.
     *
     * @param fileLocation
     * @return
     */
    public static List<String> fileToCollection(String fileLocation) {
        List<String> list = new ArrayList<>();
        try {
            list = FileUtils.readLines(new File(fileLocation), "utf-8");
        } catch (IOException ioe) {
            log.error("Unable to create a list from file: " + fileLocation, ioe);
        }
        return list;
    }

    /**
     * Compares and writes results to the item report file
     *
     * @param compareContext
     * @param fileCompareInfo
     * @param compareReportFile
     */
    public static void compareAndWriteResults(CompareService.CompareContext compareContext,
                                              FileCompareInfo fileCompareInfo,
                                              CompareReportFile compareReportFile) {
        try {
            Diff difference = DiffBuilder.compare(Input.fromFile(fileCompareInfo.getControlFile()))
                    .withTest(Input.fromFile(fileCompareInfo.getTestFile()))
                    .normalizeWhitespace()
                    .checkForSimilar()
                    .withNodeMatcher(new DefaultNodeMatcher(
                            ElementSelectors.conditionalBuilder()
                                    .whenElementIsNamed("attrib")
                                    .thenUse(ElementSelectors.byXPath("./name", ElementSelectors.byNameAndText))
                                    .elseUse(ElementSelectors.byName)
                                    .build()))
                    .build();

            Document controlXml = newXmlDocument(fileCompareInfo.getControlFile());

            for (Difference diff : difference.getDifferences()) {
                if (shouldWriteToLog(diff)) {
                    compareReportFile.write(getItemCompareLogData(compareContext, fileCompareInfo.getFileName(), diff, controlXml));
                }
            }
        } catch (Exception e) {
            if (!fileCompareInfo.getControlFile().exists()) {
                compareReportFile.write(getMissingFileData(compareContext,
                        IMPORT_FILE_NOT_FOUND,
                        fileCompareInfo.getControlFile().getName(),
                        fileCompareInfo.getControlFile().getName(),
                        fileCompareInfo.getTestFile().getName()));
            }

            if (!fileCompareInfo.getTestFile().exists()) {
                compareReportFile.write(getMissingFileData(compareContext,
                        TIMS_FILE_NOT_FOUND,
                        fileCompareInfo.getTestFile().getName(),
                        fileCompareInfo.getTestFile().getName(),
                        fileCompareInfo.getControlFile().getName()));
            }
            log.error(String.format("Error while comparing %s to %s",
                    fileCompareInfo.getControlFile(), fileCompareInfo.getTestFile()));
        }
    }

    public static void addFileReferencesToCompare(Path importedSourceDir,
                                                  CompareService.CompareContext compareContext,
                                                  ItemRelease timsRelease,
                                                  ItemRelease importedRelease) {
        if (Objects.nonNull(timsRelease.getItem())
                && Objects.nonNull(importedRelease.getItem())) {
            if (timsRelease.getItem().getMachineRubric().size() == 1
                    && importedRelease.getItem().getMachineRubric().size() == 1) {
                String timsMachineRubric = timsRelease.getItem().getMachineRubric().get(0).getFilename().replace("//", "");
                String importedMachineRubric = importedRelease.getItem().getMachineRubric().get(0).getFilename().replace("//", "");

                compareContext.fileCompareInfoList.add(new FileCompareInfo(
                        timsMachineRubric,
                        importedSourceDir.resolve(importedMachineRubric).toFile(),
                        compareContext.getCurrentItemDir().resolve(timsMachineRubric).toFile()));
            }

            if (timsRelease.getItem().getRendererSpec().size() == 1
                    && importedRelease.getItem().getRendererSpec().size() == 1) {
                String timsRenderSpec = timsRelease.getItem().getRendererSpec().get(0).getFilename().replace("//", "");
                String importedRenderSpec = importedRelease.getItem().getRendererSpec().get(0).getFilename().replace("//", "");

                compareContext.fileCompareInfoList.add(new FileCompareInfo(
                        timsRenderSpec,
                        importedSourceDir.resolve(importedRenderSpec).toFile(),
                        compareContext.getCurrentItemDir().resolve(timsRenderSpec).toFile()));
            }
        }
    }

    public static void createSummaryReport(CompareReport compareReport,
                                           List<CompareService.CompareContext> processedItems) {
        Map uniqueValues = new HashMap<Object, Integer>();
        Path summaryReport = compareReport.getCompareReportPath()
                .resolve(compareReport.getSummaryReportFileName());
        try {
            Files.write(summaryReport, "\"DifferenceType\",\"ImportElementName\",\"ImportAttributes\",\"ImportValue\",\"TimsValue\",\"Count\"\n".getBytes());

            for (CompareService.CompareContext itemContext : processedItems) {
                if (!itemContext.isFailed()) {
                    String itemId = itemContext.getItemId();
                    Path itemCsv = compareReport.getCompareReportPath().resolve(itemId.concat(".csv"));
                    if (itemCsv.toFile().exists()) {
                        Reader reader = Files.newBufferedReader(itemCsv);
                        CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT
                                .withFirstRecordAsHeader()
                                .withIgnoreHeaderCase()
                                .withTrim());

                        for (CSVRecord csvRecord : csvParser) {
                            String differenceType = csvRecord.get("DifferenceType");
                            String importElementName = csvRecord.get("ImportElementName");
                            String importAttributes = csvRecord.get("ImportAttributes");
                            String importValue = csvRecord.get("ImportValue");
                            String timsValue = csvRecord.get("TimsValue");

                            MultiKey rowKey = new MultiKey(differenceType, importElementName, importAttributes, importValue, timsValue);

                            if (Objects.isNull(uniqueValues.get(rowKey))) {
                                uniqueValues.put(rowKey, 1);
                            } else {
                                uniqueValues.put(rowKey, (Integer) uniqueValues.get(rowKey) + 1);
                            }
                        }
                    } else {
                        log.error(String.format("Item CSV file: %s was not found while processing summary report.", itemCsv));
                    }
                } else {
                    Files.write(summaryReport, getFailedItemMessage(itemContext).concat("\n").getBytes(), StandardOpenOption.APPEND);
                }
            }

            Iterator it = uniqueValues.entrySet().iterator();
            while (it.hasNext()) {
                String csvData = "";
                Map.Entry entry = (Map.Entry) it.next();
                MultiKey data = (MultiKey) entry.getKey();
                for (Object key : data.getKeys()) {
                    csvData = csvData.concat(addQuotes((String) (key))).concat(COMMA);

                }
                csvData = csvData.concat(Integer.toString((Integer) entry.getValue())).concat("\n");
                Files.write(summaryReport, csvData.getBytes(), StandardOpenOption.APPEND);
                it.remove();
            }

        } catch (IOException ex) {
            log.error(String.format("Error while processing summary report to %s", summaryReport), ex);
        }
    }

    //*****************************************************************************

    /**
     * Formats each file difference in a CSV format
     *
     * @param compareContext
     * @param fileName
     * @param diff
     * @return
     */
    private static String getItemCompareLogData(CompareService.CompareContext compareContext,
                                          String fileName,
                                          Difference diff,
                                          Document xmlDocument) {
        StringBuilder sb = new StringBuilder();
        // ItemId
        sb.append(addQuotes(
                compareContext.getItemId())).append(COMMA);
        // ItemType
        sb.append(addQuotes(
                compareContext.getItemType())).append(COMMA);
        // FileName
        sb.append(addQuotes(
                fileName)).append(COMMA);
        // DifferenceType
        sb.append(addQuotes(
                diff.getComparison().getType().name())).append(COMMA);

        Node controlElement = getControlElement(diff.getComparison(), xmlDocument);
        // ImportElementName
        sb.append(addQuotes(
                getElementName(controlElement))).append(COMMA);
        // ImportAttributes
        sb.append(addQuotes(
                getElementAttributes(controlElement))).append(COMMA);
        // ImportValue
        sb.append(addQuotes(
                getDetailValue(diff.getComparison().getControlDetails()))).append(COMMA);
        // TimsValue
        sb.append(addQuotes(
                getDetailValue(diff.getComparison().getTestDetails()))).append(COMMA);
        //ImportXPath
        sb.append(addQuotes(
                getDetailXPath(diff.getComparison().getControlDetails())));

        return sb.toString();
    }

    private static String getMissingFileData(CompareService.CompareContext compareContext,
                                             String errorType,
                                             String missingFileName,
                                             String importFileName,
                                             String timsFileName) {
        StringBuilder sb = new StringBuilder();
        // ItemId
        sb.append(addQuotes(
                compareContext.getItemId())).append(COMMA);
        // ItemType
        sb.append(addQuotes(
                compareContext.getItemType())).append(COMMA);
        // FileName
        sb.append(addQuotes(missingFileName)).append(COMMA);
        // DifferenceType
        sb.append(addQuotes(errorType)).append(COMMA);
        // ImportElementName
        sb.append(addQuotes("")).append(COMMA);
        // ImportAttributes
        sb.append(addQuotes("")).append(COMMA);
        // ImportValue
        sb.append(addQuotes(importFileName)).append(COMMA);
        // TimsValue
        sb.append(addQuotes(timsFileName)).append(COMMA);
        //ImportXPath
        sb.append(addQuotes(""));

        return sb.toString();
    }

    private static String getFailedItemMessage(CompareService.CompareContext compareContext) {
        StringBuilder sb = new StringBuilder();

        // DifferenceType
        sb.append(addQuotes("COMPARE-FAILED")).append(COMMA);
        // ImportElementName
        sb.append(addQuotes(compareContext.getItemId())).append(COMMA);
        // ImportAttributes
        sb.append(addQuotes("")).append(COMMA);
        // ImportValue
        sb.append(addQuotes("")).append(COMMA);
        // TimsValue
        sb.append(addQuotes(compareContext.getMessage())).append(COMMA);
        //Count
        sb.append(addQuotes(""));

        return sb.toString();
    }

    /**
     * @param detail
     * @return
     */
    private static String getDetailXPath(Comparison.Detail detail) {
        if (Objects.nonNull(detail.getXPath())) {
            return detail.getXPath();
        }
        return detail.getParentXPath();
    }

    /**
     * @param detail
     * @return
     */
    private static String getDetailValue(Comparison.Detail detail) {
        if (detail.getValue() instanceof QName) {
            String value = ((QName) detail.getValue()).getLocalPart();
            if (value.equals("#text")) {
                return detail.getTarget().getNodeValue();
            }
            return value;
        }
        else if (Objects.nonNull(detail.getValue())) {
            return detail.getValue().toString();
        }
        return NOT_FOUND;
    }

    private static Node getControlElement(Comparison comparison, Document document) {
        Node controlElement = null;
        if (Objects.nonNull(comparison.getControlDetails().getXPath())) {
            NodeList controlElements = getNodeList(document, comparison.getControlDetails().getXPath());
            if (Objects.nonNull(controlElements) && controlElements.getLength() == 1) {
                controlElement = controlElements.item(0);
            }
        }
        return controlElement;
    }

    private static String getElementName(Node element) {
        String printable = NOT_FOUND;
        if (element != null) {
            if (element instanceof DeferredAttrImpl) {
                element = ((DeferredAttrImpl) element).getOwnerElement();
            }
            else if (element instanceof DeferredTextImpl) {
                element = element.getParentNode();
            }
            printable = element.getNodeName();
        }
        return printable;
    }

    private static String getElementAttributes(Node element) {
        String printable = "";
        if (element != null) {
            if (element.hasAttributes()) {
                printable = formatAttributes(element.getAttributes());
            } else if (!(element instanceof DeferredAttrImpl) && element.getParentNode().hasAttributes()) {
                printable = formatAttributes(element.getParentNode().getAttributes());
            }
        }
        return printable;
    }

    private static String formatAttributes(NamedNodeMap attribs) {
        String attributes = "";
        for (int i = 0; i < attribs.getLength(); i++) {
            Attr attr = (Attr) attribs.item(i);
            if (!attr.getName().equals("xmlns")) {
                if (StringUtils.isNotBlank(attributes)) {
                    attributes = attributes + " ";
                }
                attributes = attributes + attr.getName() + "='" + attr.getValue() + "'";
            }
        }
        return attributes;
    }

    /**
     * @param value
     * @return
     */
    private static String addQuotes(String value) {
        if (Objects.nonNull(value)) {
            return QUOTE + value.replace("\"", "\"\"") + QUOTE;
        }
        return QUOTE + NOT_FOUND + QUOTE;
    }

    private static boolean shouldWriteToLog(Difference difference) {
        if ((difference.getComparison().getType().equals(ComparisonType.TEXT_VALUE) &&
                (containsHtml((String) difference.getComparison().getControlDetails().getValue()))) ||
                (difference.getComparison().getType().equals(ComparisonType.CHILD_LOOKUP) &&
                        getDetailValue(difference.getComparison().getControlDetails()).equals("#cdata-section")) ||
                difference.getComparison().getType().equals(ComparisonType.CHILD_NODELIST_LENGTH) ||
                difference.getComparison().getType().equals(ComparisonType.ELEMENT_NUM_ATTRIBUTES)) {
            return false;
        }
        return true;
    }

    /**
     * @param value
     * @return
     */
    private static boolean containsHtml(String value) {
        return value.startsWith("<p") || value.startsWith("<itemBody") || value.startsWith("<matchInteraction");
        // TODO: Improve this check
//        Pattern pattern = Pattern.compile("<(\"[^\"]*\"|'[^']*'|[^'\">])*>");
//
//        if (Objects.nonNull(value)) {
//            Matcher matcher = pattern.matcher(value);
//            return matcher.matches();
//        }
//        return false;
    }

    private static Document newXmlDocument(File xmlFile) {
        Document doc = null;
        try {
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            doc = dBuilder.parse(xmlFile);
        } catch (Exception ex) {
            log.error(String.format("Unable to load Xml Document: %s", xmlFile.toString()), ex);
        }
        return doc;
    }

    private static NodeList getNodeList(Document document, String xPathValue) {
        NodeList nodeList = null;
        try {
            XPathFactory xPathFactory = XPathFactory.newInstance();
            XPath xPath = xPathFactory.newXPath();
            XPathExpression expression = xPath.compile(xPathValue);

            nodeList = (NodeList) expression.evaluate(document, XPathConstants.NODESET);
        } catch (Exception ex) {
            log.error("Unable to create XPath expression", ex);
        }
        return nodeList;
    }
}
