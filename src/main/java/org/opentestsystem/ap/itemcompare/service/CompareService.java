package org.opentestsystem.ap.itemcompare.service;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.opentestsystem.ap.itemcompare.ApplicationProperties;
import org.opentestsystem.ap.itemcompare.comparer.ItemComparer;
import org.opentestsystem.ap.itemcompare.model.CompareContext;
import org.opentestsystem.ap.itemcompare.report.ReportWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Downloads items provided in input file
 * Extracts import.zip
 * Compares several files
 * Writes compare results to file
 */
@Slf4j
@Component
public class CompareService {
    private static final int MAX_IMPORT_ITEM_ID = 200000;

    private final ApplicationProperties applicationProperties;
    private final ItemProvider itemProvider;
    private final Set<ItemComparer> comparers;
    private final ReportService reportService;

    @Autowired
    public CompareService(final ApplicationProperties applicationProperties,
                          final ItemProvider itemProvider,
                          final Set<ItemComparer> comparers,
                          final ReportService reportService) {
        this.applicationProperties = applicationProperties;
        this.itemProvider = itemProvider;
        this.comparers = comparers;
        this.reportService = reportService;
    }

    public void compare() {
        log.info("Comparing items from {} group {}",
                this.applicationProperties.getSourceBank().getHost(),
                this.applicationProperties.getSourceBank().getGroup());

        // Read item ids from input file
        final Set<String> includedItems = fileToCollection(applicationProperties.getCompareIdFileName());

        // Determine active comparers
        final Set<ItemComparer> activeComparers = getActiveComparers();

        // Configure concurrency
        final ForkJoinPool concurrencyPool = new ForkJoinPool(applicationProperties.getNumberOfThreads());

        final String reportName = getReportName();
        try (final ReportWriter summaryReportWriter = reportService.getSummaryReportWriter(reportName, activeComparers)) {

            // Perform comparison on each item
            concurrencyPool.submit(() -> includedItems
                .parallelStream()
                .map(validateCompare())
                .map(fetchItemComparison())
                .map(compareItem(activeComparers))
                .map(reportDifferences(summaryReportWriter, reportName))
                .forEach(cleanup()))
                .get();

        } catch (final InterruptedException | ExecutionException | IOException e) {
            log.error("Problem generating comparison report", e);
        } finally {
            concurrencyPool.shutdown();
        }

        log.info(String.format("Compare processing completed. Report files are located here: %s", applicationProperties.getReportBaseDir() + "/" + reportName));
    }

    private Function<String, CompareContext> validateCompare() {
        return itemId -> {
            final CompareContext compareContext = new CompareContext(itemId);
            if (Integer.parseInt(itemId) >= MAX_IMPORT_ITEM_ID) {
                final String msg = String.format("Item %s is not imported, unable to run comparison.", itemId);
                compareContext.getErrorMessages().add(msg);
                log.error(msg);
            }
            return compareContext;
        };
    }

    private Function<CompareContext, CompareContext> fetchItemComparison() {
        return compareContext -> {
            if (compareContext.isFailed()) return compareContext;

            try {
                compareContext.setItemComparison(itemProvider.getComparison(compareContext.getItemId()));
            } catch (final Exception e) {
                logError(compareContext, e);
            }
            return compareContext;
        };
    }

    private Function<CompareContext, CompareContext> compareItem(final Collection<ItemComparer> activeComparers) {
        return compareContext -> {
            if (compareContext.isFailed()) return compareContext;

            activeComparers.forEach(comparer -> {
                try {
                    compareContext.getDifferences().addAll(
                        comparer.compare(compareContext.getItemComparison()));
                } catch (final Exception e) {
                    logError(compareContext, e);
                }
            });
            return compareContext;
        };
    }

    private Function<CompareContext, CompareContext> reportDifferences(final ReportWriter summaryReportWriter, final String reportName) {
        return compareContext -> {

            summaryReportWriter.writeDifferences(compareContext);

            try (final ReportWriter itemDifferenceWriter = reportService.getItemReportWriter(reportName, compareContext.getItemId())) {
                itemDifferenceWriter.writeDifferences(compareContext);
            } catch (final IOException e) {
                log.error("Problem writing item difference report for item [" + compareContext.getItemId() + "]", e);
            }
            return compareContext;
        };
    }

    private Consumer<CompareContext> cleanup() {
        return compareContext -> {
            if (compareContext.getItemComparison() != null) {
                itemProvider.cleanup(compareContext.getItemComparison());
            }
        };
    }

    private Set<ItemComparer> getActiveComparers() {
        final Set<String> comparerNames = applicationProperties.getComparers();
        final Set<ItemComparer> activeComparers;
        if (comparerNames.contains("all")) {
            activeComparers = comparers;
        } else {
            activeComparers = comparers.stream()
                .filter(comparer -> comparerNames.contains(comparer.getName()))
                .collect(Collectors.toSet());
        }
        return activeComparers;
    }

    private static void logError(final CompareContext compareContext, final Throwable e) {
        log.error("Problem comparing item [" + compareContext.getItemId() + "]", e);
        compareContext.getErrorMessages().add(e.getMessage());
    }

    private static Set<String> fileToCollection(final String fileLocation) {
        final Set<String> itemIds = new LinkedHashSet<>();
        try {
            itemIds.addAll(FileUtils.readLines(new File(fileLocation), "utf-8"));
        } catch (final IOException ioe) {
            log.error("Unable to create a list from file: " + fileLocation, ioe);
        }
        return itemIds;
    }

    private static String getReportName() {
        return new SimpleDateFormat("'tims-compare-'yyyyMMddHHmmss").format(new Date());
    }

}
