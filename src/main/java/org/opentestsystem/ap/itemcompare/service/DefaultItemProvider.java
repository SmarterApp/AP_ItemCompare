package org.opentestsystem.ap.itemcompare.service;

import org.apache.commons.io.FilenameUtils;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.repository.RepositoryUtil;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.common.saaif.metadata.SmarterAppMetadata;
import org.opentestsystem.ap.common.util.ZipUtil;
import org.opentestsystem.ap.itemcompare.model.ItemComparison;
import org.opentestsystem.ap.itemcompare.model.ItemReference;
import org.opentestsystem.ap.itemcompare.util.GitLabApiClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.function.Predicate;

import static org.apache.commons.lang3.StringUtils.isBlank;

/**
 * The default gitlab-backed item provider.
 */
@Service
class DefaultItemProvider implements ItemProvider {
    private static final String IMPORT_ZIP_FILENAME = "import.zip";
    private static final String TEST_ITEM_DIRECTORY = "test";
    private static final String SOURCE_ITEM_DIRECTORY = "source";
    private static final String METADATA_FILENAME = "metadata.xml";
    private static final String WORDLIST_TYPE = "WIT";

    private final GitLabApiClient gitLabApiClient;
    private final AppAssembler appAssembler;
    private final TemporaryDirectoryProvider temporaryDirectoryProvider;

    @Autowired
    public DefaultItemProvider(final GitLabApiClient gitLabApiClient,
                               final AppAssembler appAssembler,
                               final TemporaryDirectoryProvider temporaryDirectoryProvider) {
        this.gitLabApiClient = gitLabApiClient;
        this.appAssembler = appAssembler;
        this.temporaryDirectoryProvider = temporaryDirectoryProvider;
    }

    @Override
    public ItemComparison getComparison(final String itemId) {
        if (isBlank(itemId)) {
            throw new IllegalArgumentException("Cannot download blank item id: [" + itemId + "]");
        }

        try {
            final Path itemPath = temporaryDirectoryProvider.createTempDir("item-" + itemId + "-");
            final Path testItemPath = itemPath.resolve(TEST_ITEM_DIRECTORY);
            final Path sourceContentsPath = itemPath.resolve(SOURCE_ITEM_DIRECTORY);

            final Path itemArchive = gitLabApiClient.downloadItem(itemId, itemPath);
            final String itemName = FilenameUtils.removeExtension(itemArchive.toFile().getName());

            ZipUtil.unzip(itemArchive, itemPath);
            final Path unzippedTestArchivePath = Files.list(itemPath)
                .filter(Files::isDirectory)
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Unable to unzip item archive"));
            Files.move(unzippedTestArchivePath, testItemPath);
            final ItemReference testItemReference = toItemReference(itemName, testItemPath);

            final Path sourceArchive = testItemPath.resolve(IMPORT_ZIP_FILENAME);
            ZipUtil.unzip(sourceArchive, sourceContentsPath);
            final ItemReference sourceItemReference = getSourceItemReference(sourceContentsPath);

            return ItemComparison.builder()
                .itemId(itemId)
                .test(testItemReference)
                .source(sourceItemReference)
                .build();
        } catch (final IOException e) {
            throw new IllegalStateException("Cannot download item id: [" + itemId + "]", e);
        }
    }

    @Override
    public void cleanup(final ItemComparison itemComparison) {
        final Path tempDirectory = itemComparison.getTest().getItemXml().getParent().getParent();
        RepositoryUtil.deleteDirectory(tempDirectory);
    }

    private ItemReference toItemReference(final String itemName, final Path itemPath) throws IOException {
        final Path itemXml = Files.list(itemPath)
            .filter(path -> !Files.isDirectory(path) &&
                path.toFile().getName().equalsIgnoreCase(itemName + ".xml"))
            .findFirst()
            .orElseThrow(() -> new IllegalArgumentException("Cannot find item xml named: [" + itemName + ".xml]"));
        final ItemRelease parsedItem = appAssembler.getSaaifAssembler().readXmlFromFile(itemXml);

        return ItemReference.builder()
            .itemXml(itemXml)
            .itemRelease(parsedItem)
            .build();
    }

    private ItemReference getSourceItemReference(final Path sourceContentsPath) throws IOException {
        final Path unzippedSourceArchivePath = Files.list(sourceContentsPath)
            .filter(Files::isDirectory)
            .filter(hasItemMetadata())
            .findFirst()
            .orElseThrow(() -> new IllegalStateException("Unable to unzip source archive"));
        final String itemName = unzippedSourceArchivePath.toFile().getName();
        return toItemReference(itemName, unzippedSourceArchivePath);
    }

    private Predicate<Path> hasItemMetadata() {
        return path -> {
            try {
                final SmarterAppMetadata metadata = appAssembler.getSaaifAssembler().getMetadataAssembler()
                    .readXmlFromFile(path.resolve(METADATA_FILENAME));
                return !WORDLIST_TYPE.equalsIgnoreCase(metadata.getInteractionType());
            } catch (final Exception e) {
                return false;
            }
        };
    }
}
