package org.opentestsystem.ap.itemcompare.report;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.QuoteMode;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.itemcompare.model.CompareContext;
import org.opentestsystem.ap.itemcompare.model.ItemComparison;
import org.opentestsystem.ap.itemcompare.util.ItemTypeParser;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;

/**
 * CSV Summary report writer. This report writer outputs a row per CompareContext with counts of each type of
 * difference, including errors.
 */
@Slf4j
public class CsvSummaryReportWriter implements ReportWriter {
    private static final String HEADER_ITEM_ID = "ITEM_ID";
    private static final String HEADER_ITEM_TYPE = "ITEM_TYPE";
    private static final String HEADER_ERRORS = "ERRORS";

    private final ReentrantLock csvLock = new ReentrantLock();
    private final List<String> headers;
    private final CSVPrinter csvPrinter;

    public CsvSummaryReportWriter(final Path reportFile,
                                  final List<String> differenceTypes) {
        try {
            headers = getHeaders(differenceTypes);
            final BufferedWriter bufferedWriter = Files.newBufferedWriter(reportFile);
            csvPrinter = new CSVPrinter(bufferedWriter, CSVFormat.DEFAULT
                .withNullString("")
                .withQuoteMode(QuoteMode.MINIMAL)
                .withIgnoreHeaderCase()
                .withHeader(headers.toArray(new String[0])));
        } catch (final IOException e) {
            log.error("Unable to create summary report file", e);
            throw new IllegalArgumentException("Unable to create summary report file", e);
        }
    }

    @Override
    public void writeDifferences(final CompareContext compareContext) {
        final Map<String, Integer> counts = new HashMap<>();
        counts.put(HEADER_ERRORS, compareContext.getErrorMessages().size());
        compareContext.getDifferences().forEach(difference -> counts.compute(difference.getDifferenceType(),
            (key, value) -> value == null ? 1 : value + 1
        ));

        try {
            csvLock.lockInterruptibly();
            csvPrinter.printRecord(toRecord(compareContext, counts));
        } catch (final IOException e) {
            throw new RuntimeException(
                "Unable to print summary record row for item [" + compareContext.getItemId() + "]", e);
        } catch (final InterruptedException e) {
            log.error("Interrupted waiting to write summary record row for item [" + compareContext.getItemId() + "]",
                e);
        } finally {
            csvLock.unlock();
        }
    }

    @Override
    public void flush() throws IOException {
        csvPrinter.flush();
    }

    @Override
    public void close() {
        try {
            csvPrinter.close(true);
        } catch (final IOException e) {
            log.error("CsvSummaryReportWriter already closed", e);
        }
    }

    private List<String> getHeaders(final List<String> differenceTypes) {
        final List<String> headers = new ArrayList<>();
        headers.add(HEADER_ITEM_ID);
        headers.add(HEADER_ITEM_TYPE);
        headers.add(HEADER_ERRORS);
        headers.addAll(differenceTypes);
        return headers;
    }

    private List<String> toRecord(final CompareContext compareContext, final Map<String, Integer> counts) {
        final List<String> recordValues = new ArrayList<>();
        // ITEM_ID
        recordValues.add(compareContext.getItemId());

        // ITEM_TYPE
        if (compareContext.getItemComparison().isPresent()) {
            recordValues.add(getItemType(compareContext.getItemComparison().get()));
        } else {
            recordValues.add("UNKNOWN");
        }

        // ERRORS
        recordValues.add(String.valueOf(compareContext.getErrorMessages().size()));

        // Difference type counts
        headers.subList(3, headers.size()).forEach(header ->
            recordValues.add(counts.getOrDefault(header, 0).toString()));

        return recordValues;
    }

    private String getItemType(final ItemComparison itemComparison) {
        final ItemRelease testRelease = itemComparison.getTest().getItemRelease();
        final ItemRelease sourceRelease = itemComparison.getSource().getItemRelease();

        return ItemTypeParser.getItemFormat(sourceRelease, testRelease);
    }
}
