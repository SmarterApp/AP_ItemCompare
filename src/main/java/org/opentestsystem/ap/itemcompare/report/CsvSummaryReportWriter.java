package org.opentestsystem.ap.itemcompare.report;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.QuoteMode;
import org.opentestsystem.ap.itemcompare.model.CompareContext;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;

import static org.apache.commons.lang3.StringUtils.isNotBlank;

/**
 * CSV Summary report writer.
 * This report writer outputs a row per CompareContext with counts of each
 * type of difference, including errors.
 */
@Slf4j
public class CsvSummaryReportWriter implements ReportWriter {
    private static final String HEADER_ITEM_ID = "ITEM_ID";
    private static final String HEADER_ITEM_TYPE = "ITEM_TYPE";
    private static final String HEADER_ERRORS = "ERRORS";

    private final ReentrantLock csvLock = new ReentrantLock();
    private final List<String> headers;
    private final CSVPrinter csvPrinter;

    public CsvSummaryReportWriter(final Path reportFile,
                                  final List<String> differenceTypes) {
        try {
            headers = getHeaders(differenceTypes);
            final BufferedWriter bufferedWriter = Files.newBufferedWriter(reportFile);
            csvPrinter = new CSVPrinter(bufferedWriter, CSVFormat.DEFAULT
                .withNullString("")
                .withQuoteMode(QuoteMode.MINIMAL)
                .withIgnoreHeaderCase()
                .withHeader(headers.toArray(new String[0])));
        } catch (final IOException e) {
            log.error("Unable to create summary report file", e);
            throw new IllegalArgumentException("Unable to create summary report file", e);
        }
    }

    @Override
    public void writeDifferences(final CompareContext compareContext) {
        final Map<String, Integer> counts = new HashMap<>();
        counts.put(HEADER_ERRORS, compareContext.getErrorMessages().size());
        compareContext.getDifferences().forEach(difference -> counts.compute(difference.getDifferenceType(),
            (key, value) -> value == null ? 1 : value + 1
        ));

        try {
            csvLock.lockInterruptibly();
            csvPrinter.printRecord(toRecord(compareContext, counts));
        } catch (final IOException e) {
            throw new RuntimeException("Unable to print summary record row for item [" + compareContext.getItemId() + "]", e);
        } catch (final InterruptedException e) {
            log.error("Interrupted waiting to write summary record row for item [" + compareContext.getItemId() + "]", e);
        } finally {
            csvLock.unlock();
        }
    }

    @Override
    public void flush() throws IOException {
        csvPrinter.flush();
    }

    @Override
    public void close() {
        try {
            csvPrinter.close(true);
        } catch (final IOException e) {
            log.error("CsvSummaryReportWriter already closed", e);
        }
    }

    private List<String> getHeaders(final List<String> differenceTypes) {
        final List<String> headers = new ArrayList<>();
        headers.add(HEADER_ITEM_ID);
        headers.add(HEADER_ITEM_TYPE);
        headers.add(HEADER_ERRORS);
        headers.addAll(differenceTypes);
        return headers;
    }

    private List<String> toRecord(final CompareContext compareContext, final Map<String, Integer> counts) {
        final List<String> recordValues = new ArrayList<>();
        // ITEM_ID
        recordValues.add(compareContext.getItemId());

        // ITEM_TYPE
        if (compareContext.getItemComparison() != null) {
            if (compareContext.getItemComparison().getTest() != null
                && compareContext.getItemComparison().getTest().getItemRelease() != null
                && compareContext.getItemComparison().getTest().getItemRelease().getItem() != null
                && isNotBlank(compareContext.getItemComparison().getTest().getItemRelease().getItem().getFormat())) {
                recordValues.add(compareContext.getItemComparison().getTest().getItemRelease().getItem().getFormat());
            } else if (compareContext.getItemComparison().getSource() != null
                && compareContext.getItemComparison().getSource().getItemRelease() != null
                && compareContext.getItemComparison().getSource().getItemRelease().getItem() != null
                && isNotBlank(compareContext.getItemComparison().getSource().getItemRelease().getItem().getFormat())) {
                recordValues.add(compareContext.getItemComparison().getSource().getItemRelease().getItem().getFormat());
            } else {
                recordValues.add("UNKNOWN");
            }
        }

        // ERRORS
        recordValues.add(String.valueOf(compareContext.getErrorMessages().size()));

        // Difference type counts
        headers.subList(3, headers.size()).forEach(header ->
            recordValues.add(counts.getOrDefault(header, 0).toString()));

        return recordValues;
    }
}
