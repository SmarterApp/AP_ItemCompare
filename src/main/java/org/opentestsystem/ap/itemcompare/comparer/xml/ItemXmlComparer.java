package org.opentestsystem.ap.itemcompare.comparer.xml;

import lombok.extern.slf4j.Slf4j;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.itemcompare.comparer.ItemComparer;
import org.opentestsystem.ap.itemcompare.model.ItemComparison;
import org.opentestsystem.ap.itemcompare.model.ItemDifference;
import org.springframework.stereotype.Service;
import org.xmlunit.builder.DiffBuilder;
import org.xmlunit.builder.Input;
import org.xmlunit.diff.Comparison;
import org.xmlunit.diff.ComparisonType;
import org.xmlunit.diff.DefaultNodeMatcher;
import org.xmlunit.diff.Diff;
import org.xmlunit.diff.Difference;
import org.xmlunit.diff.ElementSelectors;

import javax.xml.namespace.QName;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * This comparer performs an XML comparison on the:<ul>
 *     <li>item definition xml</li>
 *     <li>machine rubric xml (if present)</li>
 *     <li>render spec xml (if present)</li>
 * </ul>
 */
@Service
@Slf4j
class ItemXmlComparer implements ItemComparer {
    static final String NAME = "xml";
    private static final String IMPORT_FILE_NOT_FOUND = "IMPORT_FILE_NOT_FOUND";
    private static final String TIMS_FILE_NOT_FOUND = "TIMS_FILE_NOT_FOUND";
    private static final String NOT_FOUND_VALUE = "NOT FOUND";

    @Override
    public String getName() {
        return NAME;
    }

    @Override
    public List<String> getDifferenceTypes() {
        final List<String> differenceTypes = new ArrayList<>();
        differenceTypes.add(IMPORT_FILE_NOT_FOUND);
        differenceTypes.add(TIMS_FILE_NOT_FOUND);
        differenceTypes.addAll(Arrays.stream(ComparisonType.values())
            .map(ComparisonType::name)
            .collect(Collectors.toList()));
        return differenceTypes;
    }

    @Override
    public List<ItemDifference> compare(final ItemComparison itemComparison) {
        final List<FileCompareInfo> filesToCompare = getFilesToCompare(itemComparison);
        return filesToCompare.stream()
            .flatMap(getDifferences())
            .collect(Collectors.toList());
    }

    private List<FileCompareInfo> getFilesToCompare(final ItemComparison itemComparison) {
        final List<FileCompareInfo> filesToCompare = new ArrayList<>();

        //Add item definition xml
        final Path testItemXml = itemComparison.getTest().getItemXml();
        final Path sourceItemXml = itemComparison.getSource().getItemXml();
        filesToCompare.add(new FileCompareInfo(
            testItemXml.toFile().getName(),
            sourceItemXml.toFile(),
            testItemXml.toFile()));

        final ItemRelease testRelease = itemComparison.getTest().getItemRelease();
        final ItemRelease sourceRelease = itemComparison.getSource().getItemRelease();
        if (testRelease.getItem() == null || sourceRelease.getItem() == null) {
            return filesToCompare;
        }

        //Add machine rubric
        if (sourceRelease.getItem().getMachineRubric().size() == 1
            && testRelease.getItem().getMachineRubric().size() == 1) {
            final File testMachineRubric = getReferencedResource(
                testItemXml.getParent(),
                testRelease.getItem().getMachineRubric().get(0).getFilename());
            final File sourceMachineRubric = getReferencedResource(
                sourceItemXml.getParent(),
                sourceRelease.getItem().getMachineRubric().get(0).getFilename());
            filesToCompare.add(new FileCompareInfo(
                testMachineRubric.getName(),
                sourceMachineRubric,
                testMachineRubric));
        }

        //Add renderer spec
        if (sourceRelease.getItem().getRendererSpec().size() == 1
            && testRelease.getItem().getRendererSpec().size() == 1) {
            final File testRendererSpec = getReferencedResource(
                testItemXml.getParent(),
                testRelease.getItem().getRendererSpec().get(0).getFilename());
            final File sourceRendererSpec = getReferencedResource(
                sourceItemXml.getParent(),
                sourceRelease.getItem().getRendererSpec().get(0).getFilename());
            filesToCompare.add(new FileCompareInfo(
                testRendererSpec.getName(),
                sourceRendererSpec,
                testRendererSpec));
        }

        return filesToCompare;
    }

    private File getReferencedResource(final Path directory, final String filename) {
        try {
            final String cleanFilename = filename.replace("//", "");
            return Files.list(directory)
                .filter(path -> path.toFile().getName().equalsIgnoreCase(cleanFilename))
                .findFirst()
                .orElse(directory.resolve(cleanFilename))
                .toFile();
        } catch (final IOException e) {
            throw new IllegalArgumentException("Cannot find referenced file [" + filename + "]" +
                " in path [" + directory.toString() + "]", e);
        }
    }

    private Function<FileCompareInfo, Stream<ItemDifference>> getDifferences() {
        return fileCompareInfo -> {

            if (!fileCompareInfo.getControlFile().exists()
                || !fileCompareInfo.getTestFile().exists()) {
                return getExistenceDifferences(fileCompareInfo).stream();
            }

            final Diff diff = DiffBuilder.compare(Input.fromFile(fileCompareInfo.getControlFile()))
                .withTest(Input.fromFile(fileCompareInfo.getTestFile()))
                .normalizeWhitespace()
                .checkForSimilar()
                .withNodeMatcher(new DefaultNodeMatcher(
                    ElementSelectors.conditionalBuilder()
                        .whenElementIsNamed("attrib")
                        .thenUse(ElementSelectors.byXPath("./name", ElementSelectors.byNameAndText))
                        .elseUse(ElementSelectors.byName)
                        .build()))
                .build();

            return StreamSupport.stream(diff.getDifferences().spliterator(), false)
                .filter(shouldReportDifference())
                .map(difference -> ItemDifference.builder()
                    .filename(fileCompareInfo.getFileName())
                    .differenceType(difference.getComparison().getType().name())
                    .location(getXPath(difference.getComparison()))
                    .sourceValue(getDetailValue(difference.getComparison().getControlDetails()))
                    .testValue(getDetailValue(difference.getComparison().getTestDetails()))
                    .build());
        };
    }

    private List<ItemDifference> getExistenceDifferences(final FileCompareInfo fileCompareInfo) {
        final List<ItemDifference> differences = new ArrayList<>();
        if (!fileCompareInfo.getControlFile().exists()) {
            differences.add(ItemDifference.builder()
                .filename(fileCompareInfo.getControlFile().getName())
                .differenceType(IMPORT_FILE_NOT_FOUND)
                .location("")
                .sourceValue(fileCompareInfo.getControlFile().getName())
                .testValue(fileCompareInfo.getTestFile().getName())
                .build());
        }
        if (!fileCompareInfo.getTestFile().exists()) {
            differences.add(ItemDifference.builder()
                .filename(fileCompareInfo.getTestFile().getName())
                .differenceType(TIMS_FILE_NOT_FOUND)
                .location("")
                .sourceValue(fileCompareInfo.getControlFile().getName())
                .testValue(fileCompareInfo.getTestFile().getName())
                .build());
        }
        return differences;
    }

    private String getXPath(final Comparison comparison) {
        if (comparison.getControlDetails().getXPath() != null) {
            return comparison.getControlDetails().getXPath();
        }
        if (comparison.getTestDetails().getXPath() != null) {
            return comparison.getTestDetails().getXPath();
        }
        if (comparison.getControlDetails().getParentXPath() != null) {
            return comparison.getControlDetails().getParentXPath();
        }
        if (comparison.getTestDetails().getParentXPath() != null) {
            return comparison.getTestDetails().getParentXPath();
        }
        return "";
    }

    private static String getDetailValue(final Comparison.Detail detail) {
        if (detail.getValue() instanceof QName) {
            final String value = ((QName) detail.getValue()).getLocalPart();
            if (value.equals("#text")) {
                return detail.getTarget().getNodeValue();
            }
            return value;
        }
        else if (Objects.nonNull(detail.getValue())) {
            return detail.getValue().toString();
        }
        return NOT_FOUND_VALUE;
    }

    private static Predicate<Difference> shouldReportDifference() {
        return difference -> (!difference.getComparison().getType().equals(ComparisonType.TEXT_VALUE) ||
            (!containsHtml((String) difference.getComparison().getControlDetails().getValue()))) &&
            (!difference.getComparison().getType().equals(ComparisonType.CHILD_LOOKUP) ||
                !getDetailValue(difference.getComparison().getControlDetails()).equals("#cdata-section")) &&
            !difference.getComparison().getType().equals(ComparisonType.CHILD_NODELIST_LENGTH) &&
            !difference.getComparison().getType().equals(ComparisonType.ELEMENT_NUM_ATTRIBUTES);
    }

    private static boolean containsHtml(final String value) {
        return value.startsWith("<p") || value.startsWith("<itemBody") || value.startsWith("<matchInteraction");
        // TODO: Improve this check
//        Pattern pattern = Pattern.compile("<(\"[^\"]*\"|'[^']*'|[^'\">])*>");
//
//        if (Objects.nonNull(value)) {
//            Matcher matcher = pattern.matcher(value);
//            return matcher.matches();
//        }
//        return false;
    }
}
