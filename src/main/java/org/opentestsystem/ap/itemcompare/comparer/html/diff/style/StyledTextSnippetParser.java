package org.opentestsystem.ap.itemcompare.comparer.html.diff.style;

import com.google.common.collect.Lists;
import com.google.common.collect.Range;
import com.steadystate.css.parser.CSSOMParser;
import com.steadystate.css.parser.SACParserCSS3;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.tuple.Pair;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.parser.Tag;
import org.springframework.stereotype.Component;
import org.w3c.css.sac.InputSource;
import org.w3c.dom.css.CSSStyleDeclaration;

import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import static com.google.common.collect.Lists.newArrayList;
import static org.apache.commons.lang3.StringUtils.isNotBlank;

/**
 * This class is responsible for parsing an HTML document
 * and flattening the contained text into an ordered list of styled
 * text snippets.
 */
@Slf4j
@Component
class StyledTextSnippetParser {

    /**
     * Parse an HTML document and retrieve a flat list of style-annoted
     * text snippets with character range information.
     *
     * @param document  An HTML document
     * @return  The flat list of text snippets
     */
    public List<StyledTextSnippet> parseDocument(final Document document) {
        final ParserContext context = new ParserContext();

        //Begin with the document body and process the document HTML nodes depth-first
        context.getProcessingQueue().push(Pair.of(document.body(), AppliedStyles.builder().build()));

        while (!context.getProcessingQueue().isEmpty()) {
            final Pair<Node, AppliedStyles> currentElement = context.getProcessingQueue().pop();
            context.setCurrentNode(currentElement.getLeft());
            context.setCurrentStyles(currentElement.getRight());

            if (context.getCurrentNode() instanceof TextNode) {
                processTextNode(context);
                continue;
            }

            if (context.getCurrentNode() instanceof Element) {
                processElement(context);
            }
        }
        return newArrayList(context.snippetQueue);
    }

    private void processTextNode(final ParserContext context) {
        final TextNode node = (TextNode) context.getCurrentNode();
        String nodeContent = node.text();

        //Apply the implicit block element space if the previous snippet doesn't end in whitespace
        final boolean trailingSpace = !context.getSnippetQueue().isEmpty() && context.getSnippetQueue().getLast().getContent().endsWith(" ");
        if (!trailingSpace && context.isAddBlockElementSpace()) {
            nodeContent = " " + nodeContent;
        }
        context.setAddBlockElementSpace(false);

        //If this node has the same styles applied as the previous snippet,
        //append this node to the previous snippet.
        if (!context.getSnippetQueue().isEmpty()
            && context.getCurrentStyles().equals(context.getSnippetQueue().getLast().getStyles())) {
            appendSnippetContent(context, nodeContent);
        }
        //Else, add a new snippet for this new styled text
        else {
            createSnippet(context, nodeContent);
        }
    }

    private void appendSnippetContent(final ParserContext context, final String nodeContent) {
        final StyledTextSnippet originalSnippet = context.getSnippetQueue().removeLast();
        final String newContent = collapseWhitespace(originalSnippet.getContent() + nodeContent);

        // Calculate the number of characters we have advanced the character index
        final int characterAdvance = newContent.length() - originalSnippet.getContent().length();
        context.getCharacterIndex().addAndGet(characterAdvance);

        // Calculate the new range.  Account for initial leading whitespace.
        final int rangeStart = originalSnippet.getRange().lowerEndpoint();
        final int rangeLength = newContent.startsWith(" ") ? newContent.length() - 1 : newContent.length();
        final Range<Integer> newRange = Range.closedOpen(rangeStart, rangeStart + rangeLength);

        context.getSnippetQueue().addLast(StyledTextSnippet.builder()
            .styles(originalSnippet.getStyles())
            .content(newContent)
            .range(newRange)
            .build());
    }

    private void createSnippet(final ParserContext context, final String nodeContent) {
        String newContent = collapseWhitespace(nodeContent);

        //If this is the first content, trim any leading spaces
        if (context.getSnippetQueue().isEmpty()) {
            newContent = newContent.replaceAll("^\\s+", "");
        }

        //Calculate the number of characters we have advanced the character index
        final int characterStart = context.getCharacterIndex().getAndAdd(newContent.length());

        //Calculate the new range. Trim off leading whitespace
        //to avoid whitespace overlaps when calculating differences.
        final int rangeStart = newContent.startsWith(" ") ? characterStart + 1 : characterStart;
        final Range<Integer> newRange = Range.closedOpen(rangeStart, characterStart + newContent.length());

        context.getSnippetQueue().addLast(StyledTextSnippet.builder()
            .styles(context.getCurrentStyles())
            .content(newContent)
            .range(newRange)
            .build());
    }

    private String collapseWhitespace(final String source) {
        return source.replaceAll("[\\s\\u00A0]+", " ");
    }

    private void processElement(final ParserContext context) {
        final Element element = (Element) context.getCurrentNode();

        if (element.isBlock() && element.previousSibling() != null) {
            context.setAddBlockElementSpace(true);
        }
        final AppliedStyles newStyles = mergeElementStyles(element, context.getCurrentStyles());

        //Insert children into the queue in reverse order to perform depth-first processing
        final List<Node> reverseChildren = Lists.reverse(newArrayList(element.childNodes()));
        reverseChildren.forEach(child -> context.getProcessingQueue().push(Pair.of(child, newStyles)));
    }

    private AppliedStyles mergeElementStyles(final Element element, final AppliedStyles parentStyles) {
        final Tag tag = element.tag();
        if (tag.isEmpty()) return parentStyles;

        // Check for known style-applying tags
        switch (tag.getName().toLowerCase()) {
            case "b":
            case "strong":
                return parentStyles.toBuilder().bold(true).build();
            case "i":
            case "em":
                return parentStyles.toBuilder().italics(true).build();
            case "u":
                return parentStyles.toBuilder().underline(true).build();
            case "sup":
                return parentStyles.toBuilder().superscript(true).build();
            case "sub":
                return parentStyles.toBuilder().subscript(true).build();
        }

        // Check for CSS styling
        if (!element.hasAttr("style")) return parentStyles;

        final AppliedStyles cssAppliedStyles = parentStyles.toBuilder().build();
        final String cssStyleDefinition = element.attr("style");
        try (final StringReader cssStyleReader = new StringReader(cssStyleDefinition)) {
            final InputSource inputSource = new InputSource(cssStyleReader);
            final CSSOMParser parser = new CSSOMParser(new SACParserCSS3());
            final CSSStyleDeclaration decl = parser.parseStyleDeclaration(inputSource);

            final String fontWeight = decl.getPropertyValue("font-weight");
            if (isNotBlank(fontWeight)) {
                if ("bold".equalsIgnoreCase(fontWeight)) {
                    cssAppliedStyles.setBold(true);
                }
                if ("normal".equalsIgnoreCase(fontWeight)) {
                    cssAppliedStyles.setBold(false);
                }
            }

            final String fontStyle = decl.getPropertyValue("font-style");
            if (isNotBlank(fontStyle)) {
                if ("italic".equalsIgnoreCase(fontStyle) || "oblique".equalsIgnoreCase(fontStyle)) {
                    cssAppliedStyles.setItalics(true);
                }
                if ("normal".equalsIgnoreCase(fontStyle)) {
                    cssAppliedStyles.setItalics(false);
                }
            }

            final String textDecoration = decl.getPropertyValue("text-decoration");
            if (isNotBlank(textDecoration)) {
                if (textDecoration.toLowerCase().contains("underline")) {
                    cssAppliedStyles.setUnderline(true);
                }
            }

            final String fontSize = decl.getPropertyValue("font-size");
            if (isNotBlank(fontSize)) {
                cssAppliedStyles.setFontSize(fontSize);
            }

        } catch (final IOException e) {
            log.warn("Problem parsing Element CSS", e);
        }

        return parentStyles.equals(cssAppliedStyles) ? parentStyles : cssAppliedStyles;
    }

    @Data
    private static class ParserContext {

        private Deque<StyledTextSnippet> snippetQueue = new ArrayDeque<>();
        private Deque<Pair<Node, AppliedStyles>> processingQueue = new ArrayDeque<>();
        private boolean addBlockElementSpace;
        private AtomicInteger characterIndex = new AtomicInteger(0);
        private Node currentNode;
        private AppliedStyles currentStyles;
    }

}
