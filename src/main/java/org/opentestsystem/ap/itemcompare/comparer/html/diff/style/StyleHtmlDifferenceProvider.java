package org.opentestsystem.ap.itemcompare.comparer.html.diff.style;

import com.github.difflib.DiffUtils;
import com.github.difflib.algorithm.DiffException;
import com.github.difflib.patch.AbstractDelta;
import com.github.difflib.patch.DeltaType;
import com.github.difflib.patch.Patch;
import com.google.common.base.Joiner;
import com.google.common.collect.Range;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.tuple.Pair;
import org.opentestsystem.ap.itemcompare.comparer.html.HtmlComparisonContext;
import org.opentestsystem.ap.itemcompare.comparer.html.diff.HtmlDifferenceProvider;
import org.opentestsystem.ap.itemcompare.model.ItemDifference;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static java.util.Collections.emptyList;
import static org.apache.commons.lang3.StringUtils.isNotBlank;
import static org.opentestsystem.ap.itemcompare.comparer.html.diff.HtmlDifferenceProvider.DifferenceType.STYLE_DIFFERENCE;

/**
 * This difference provider is responsible for reporting
 * style differences between the source and test html.
 */
@Component
@Slf4j
class StyleHtmlDifferenceProvider implements HtmlDifferenceProvider {
    private static final Joiner LabelJoiner = Joiner.on(",");

    private final StyledTextSnippetParser snippetParser;

    @Autowired
    public StyleHtmlDifferenceProvider(final StyledTextSnippetParser snippetParser) {
        this.snippetParser = snippetParser;
    }

    @Override
    public List<ItemDifference> getDifferences(final HtmlComparisonContext comparisonDocuments) {
        if (!comparisonDocuments.getSourceDocument().isPresent()
            || !comparisonDocuments.getTestDocument().isPresent()) {
            return emptyList();
        }

        final List<StyledTextSnippet> sourceStyledText = snippetParser
            .parseDocument(comparisonDocuments.getSourceDocument().get());
        final List<StyledTextSnippet> testStyledText = snippetParser
            .parseDocument(comparisonDocuments.getTestDocument().get());

        return reportDifferences(comparisonDocuments, sourceStyledText, testStyledText);
    }

    private List<ItemDifference> reportDifferences(final HtmlComparisonContext comparisonDocuments,
                                                   final List<StyledTextSnippet> sourceStyledTextSnippets,
                                                   final List<StyledTextSnippet> testStyledTextSnippets) {
        final List<ItemDifference> styleDifferences = new ArrayList<>();

        final String sourceText = sourceStyledTextSnippets.stream()
            .map(StyledTextSnippet::getContent)
            .collect(Collectors.joining());
        final String testText = testStyledTextSnippets.stream()
            .map(StyledTextSnippet::getContent)
            .collect(Collectors.joining());

        try {
            final Patch<String> patch = DiffUtils.diffInline(sourceText, testText);
            final List<Pair<Integer, Integer>> positionLengthChange = patch.getDeltas().stream()
                .map(delta -> Pair.of(delta.getSource().getPosition(), getLengthDelta(delta)))
                .collect(Collectors.toList());

            testStyledTextSnippets.forEach(testSnippet -> {
                final Range<Integer> sourceRange = getSourceRange(positionLengthChange, testSnippet.getRange());
                if (sourceRange.isEmpty()) {
                    return;
                }
                final List<StyledTextSnippet> sourceSnippets = getSnippetsForRange(sourceStyledTextSnippets, sourceRange);
                if (sourceSnippets.size() == 1 && sourceSnippets.get(0).getStyles().equals(testSnippet.getStyles())) {
                    //No change
                    return;
                }

                final String sourceContent = sourceSnippets.stream()
                    .map(this::wrapWithStyles)
                    .collect(Collectors.joining());
                final String testContent = this.wrapWithStyles(testSnippet);
                styleDifferences.add(ItemDifference.builder()
                    .differenceType(STYLE_DIFFERENCE.name())
                    .location(comparisonDocuments.getComparison().getLocation())
                    .filename(comparisonDocuments.getFilename())
                    .sourceValue(sourceContent)
                    .testValue(testContent)
                    .build());
            });
            return styleDifferences;
        } catch (final DiffException e) {
            throw new IllegalStateException("Unable to calculate HTML diff", e);
        }
    }

    private List<StyledTextSnippet> getSnippetsForRange(final List<StyledTextSnippet> sourceStyledTextSnippets,
                                                                                    final Range<Integer> sourceRange) {
        final List<StyledTextSnippet> snippetsInRange = new ArrayList<>();
        for (final StyledTextSnippet snippet : sourceStyledTextSnippets) {
            if (snippet.getRange().lowerEndpoint() >= sourceRange.upperEndpoint()) break;

            if (!snippet.getRange().isConnected(sourceRange)) continue;
            if (snippet.getRange().intersection(sourceRange).isEmpty()) continue;

            snippetsInRange.add(snippet);
        }

        return snippetsInRange;
    }

    private Range<Integer> getSourceRange(final List<Pair<Integer, Integer>> positionLengthChanges, final Range<Integer> testRange) {
        int originalLowerBound = testRange.lowerEndpoint();
        int originalUpperBound = testRange.upperEndpoint();
        int lowerBound = testRange.lowerEndpoint();
        int upperBound = testRange.upperEndpoint();
        for (final Pair<Integer, Integer> positionLengthChange : positionLengthChanges) {
            final int position = positionLengthChange.getLeft();
            if (position > originalUpperBound) break;
            if (position <= originalLowerBound) {
                lowerBound += positionLengthChange.getRight();
            }
            upperBound += positionLengthChange.getRight();
        }

        //The test snippet was completely removed.  Return empty ran to move to next snippet
        if(lowerBound > upperBound) {
            return Range.closedOpen(lowerBound,lowerBound);
        }

        return Range.closedOpen(lowerBound, upperBound);
    }

    private int getLengthDelta(final AbstractDelta<String> delta) {
        if (DeltaType.EQUAL == delta.getType()) return 0;

        final int charactersRemoved = changeLength(delta.getSource().getLines());
        final int charactersAdded = changeLength(delta.getTarget().getLines());

        return charactersRemoved - charactersAdded;
    }

    private int changeLength(final List<String> strings) {
        return strings.stream()
            .map(String::length)
            .reduce(0, (total, lineLength) -> total + lineLength);
    }

    private String wrapWithStyles(final StyledTextSnippet snippet) {
        final AppliedStyles appliedStyles = snippet.getStyles();
        final List<String> labels = new ArrayList<>();
        if (appliedStyles.isBold()) {
            labels.add("BOLD");
        }
        if (appliedStyles.isItalics()) {
            labels.add("ITALIC");
        }
        if (appliedStyles.isUnderline()) {
            labels.add("UNDERLINED");
        }
        if (appliedStyles.isSuperscript()) {
            labels.add("SUPERSCRIPT");
        }
        if (appliedStyles.isSubscript()) {
            labels.add("SUBSCRIPT");
        }
        if (isNotBlank(appliedStyles.getFontSize())) {
            labels.add("FONTSIZE:" + appliedStyles.getFontSize());
        }
        if (labels.isEmpty()) return snippet.getContent();

        final String tag = LabelJoiner.join(labels);
        return "<" + tag + ">" + snippet.getContent() + "</" + tag + ">";
    }

}
